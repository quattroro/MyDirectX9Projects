#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

// N -> 원의 개수
// M -> 수의 개수
// T -> 회전 횟수


int board[50][50];
int N = 0;
int M = 0;
int T = 0;
bool isequal = false;


struct RotRule
{
	RotRule()
	{
		index = 0;
		dir = 0;
		num = 0;
	}

	RotRule(int _index, int _dir, int _num)
	{
		index = _index;
		dir = _dir;
		num = _num;
	}
	int index; 
	int dir;
	int num;
};
vector<RotRule> rules;

void CheckEqual(int x, int y, int num)
{
	if (x < 0 || y < 0 || x >= M || y >= N)
		return;

	if (/*x + 1 < M &&*/ board[y][(x + 1) % M] == num)
	{
		isequal = true;
		board[y][x] = 0;
		board[y][(x + 1) % M] = 0;
		CheckEqual((x + 1) % M, y, num);
	}
	if (/*x - 1 >= 0 &&*/  board[y][(x + M - 1) % M] == num)
	{
		isequal = true;
		board[y][x] = 0;
		board[y][(x + M - 1) % M] = 0;
		CheckEqual((x + M - 1) % M, y, num);
	}
	if (y + 1 < N && board[y + 1][x] == num)
	{
		isequal = true;
		board[y][x] = 0;
		board[y + 1][x] = 0;
		CheckEqual(x, y + 1, num);
	}
	if (y - 1 >= 0 && board[y - 1][x] == num)
	{
		isequal = true;
		board[y][x] = 0;
		board[y - 1][x] = 0;
		CheckEqual(x, y - 1, num);
	}

}

void EraseEqualNum()
{
	isequal = false;
	int sum = 0;
	int count = 0;

	for (int y = 0; y < N; y++)
	{
		for (int x = 0; x < M; x++)
		{
			if (board[y][x] != 0)
			{
				count++;
				sum += board[y][x];
				CheckEqual(x, y, board[y][x]);
			}
		}
	}


	if (!isequal)
	{
		float eve = (float)sum / (float)count;
		for (int y = 0; y < N; y++)
		{
			for (int x = 0; x < M; x++)
			{
				if (board[y][x] != 0 && (float)board[y][x] < eve)
				{
					board[y][x]++;
				}
				else if(board[y][x] != 0 && (float)board[y][x] > eve)
				{
					board[y][x]--;
				}
			}
		}
	}
	
}

void Rotation(RotRule rule)
{
	int temp[50] = { 0 };

	for (int y = 0; y < N; y++)
	{
		memset(temp, 0, sizeof(int) * M);

		if ((y + 1) % rule.index == 0)
		{
			// 시계방향
			if (!rule.dir)
			{
				for (int x = 0; x < M; x++)
				{
					temp[(x + rule.num) % M] = board[y][x];
				}
				memcpy(board[y], temp, sizeof(int) * M);
			}
			// 반시계방향
			else
			{
				for (int x = 0; x < M; x++)
				{
					temp[(x + M - (rule.num % M)) % M] = board[y][x];
				}
				memcpy(board[y], temp, sizeof(int) * M);
			}
		}
	}
}

int GetSum()
{
	for (int i = 0; i < rules.size(); i++)
	{
		// 원판 회전
		Rotation(rules[i]);

		// 한번의 회전이 끝나면 인접한 같은 숫자들을 지워준다.
		EraseEqualNum();
	}

	int sum = 0;
	int count = 0;

	for (int y = 0; y < N; y++)
	{
		for (int x = 0; x < M; x++)
		{
			if (board[y][x] != 0)
			{
				sum += board[y][x];
			}
		}
	}

	return sum;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> N;
	cin >> M;
	cin >> T;

	rules.clear();

	for (int y = 0; y < N; y++)
	{
		for (int x = 0; x < M; x++)
		{
			cin >> board[y][x];
		}
	}

	for (int t = 0; t < T; t++)
	{
		int x; int d; int k;
		cin >> x; cin >> d; cin >> k;
		rules.push_back(RotRule(x, d, k));
	}

	cout << GetSum();

	int a = 0;
	return 0;
}